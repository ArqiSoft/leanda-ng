# 0007. Cost Optimization Strategy

## Status
Accepted

## Context

Leanda.io is an open science data repository platform running on AWS with 11 microservices, multiple databases, storage, and messaging infrastructure. As the platform scales, cost management becomes critical to ensure sustainable operations while maintaining performance and reliability.

Key cost drivers identified:
- ECS Fargate compute resources (11 microservices)
- DocumentDB database instances
- S3 storage (scientific data can grow to petabytes)
- MSK Serverless messaging
- ElastiCache Redis
- Data transfer costs
- CloudWatch logging and monitoring

## Decision

Implement a comprehensive FinOps strategy with the following components:

### 1. Cost Allocation and Tagging

**Mandatory Tags**:
- `Project`: leanda-ng
- `Environment`: dev | staging | prod
- `Service`: service-name (e.g., core-api, blob-storage)
- `CostCenter`: department/budget code
- `Owner`: team/individual email

**Implementation**:
- All CDK stacks apply tags automatically via tagging utility
- Tags propagated to all resources (ECS, DocumentDB, S3, MSK, etc.)
- Cost allocation reports generated by tag

### 2. AWS Budgets and Cost Monitoring

**Budget Configuration**:
- Total cost budget per environment (dev: $1,000, staging: $5,000, prod: $10,000)
- Service-level budget (80% of total for core services)
- Alerts at 50%, 80%, and 100% thresholds
- Forecasted budget alerts

**Cost Monitoring**:
- AWS Cost Explorer for cost analysis
- CloudWatch cost dashboard (placeholder for manual setup)
- Cost anomaly detection (manual setup required)
- Monthly cost reviews

### 3. Compute Optimization

**ECS Fargate**:
- Right-sizing: Start with 0.25 vCPU / 512MB, scale based on metrics
- Auto-scaling: Target CPU 70%, Memory 80%
- Graviton (ARM) instances: 20-40% cost savings (future enhancement)
- Scheduled scaling: Scale down non-production during off-hours

**Lambda** (future):
- Right-size memory (use Lambda Power Tuning)
- ARM64 runtime for 20% cost savings
- Provisioned concurrency only for latency-critical APIs

### 4. Storage Optimization

**S3 Lifecycle Policies**:
- Intelligent-Tiering: Automatic cost optimization for unpredictable access
- Standard-IA: After 30 days (if not using Intelligent-Tiering)
- Glacier: After 90 days for cold data
- Glacier Deep Archive: After 180 days for archival data
- Expire incomplete multipart uploads after 7 days

**S3 Storage Classes**:
- Standard: Hot data (frequent access)
- Intelligent-Tiering: Automatic optimization
- Glacier: Cold data (12-hour retrieval)
- Deep Archive: Archival data (12-hour retrieval, lowest cost)

### 5. Database Optimization

**DocumentDB**:
- Right-sizing: Start with db.t3.medium, scale based on usage
- Read replicas: For read-heavy workloads (cost-effective scaling)
- Reserved Instances: For predictable workloads (1-year or 3-year)
- Multi-AZ: Production only (2+ instances)

**ElastiCache Redis**:
- Right-sizing: Start with cache.t3.micro, scale based on usage
- Reserved capacity: For predictable workloads

### 6. Network Optimization

**VPC Endpoints**:
- Use VPC endpoints for AWS service access (reduce NAT Gateway costs)
- Private connectivity to S3, DynamoDB, etc.

**Data Transfer**:
- Minimize cross-region data transfer
- Use CloudFront for content delivery (caching reduces origin requests)
- Compress data in transit (gzip, brotli)

### 7. Reserved Capacity and Savings Plans

**Reserved Instances**:
- DocumentDB: 1-year or 3-year commitments for predictable workloads
- ElastiCache: Reserved capacity for predictable workloads

**Savings Plans**:
- Compute Savings Plans: For ECS Fargate (future)
- EC2 Instance Savings Plans: For EC2-based services (if any)

### 8. Cost Review Process

**Monthly Reviews**:
- Review AWS Cost Explorer reports
- Identify cost anomalies and optimization opportunities
- Right-size resources based on actual usage
- Review and adjust budgets

**Quarterly Reviews**:
- Evaluate Reserved Instance opportunities
- Review Savings Plans coverage
- Analyze cost per user, cost per data volume
- Document cost optimization decisions

## Consequences

### Positive

- **Cost Visibility**: Comprehensive tagging enables cost allocation by service, environment, and team
- **Proactive Cost Management**: Budget alerts prevent cost overruns
- **Automated Optimization**: S3 Intelligent-Tiering automatically optimizes storage costs
- **Right-Sizing**: Regular reviews ensure resources match actual usage
- **Cost Predictability**: Reserved capacity and Savings Plans provide cost predictability

### Negative

- **Initial Setup Overhead**: Requires manual setup of Cost Anomaly Detection and billing alarms
- **Tagging Discipline**: Requires discipline to maintain consistent tagging across all resources
- **Budget Management**: Requires regular review and adjustment of budgets
- **Storage Retrieval Costs**: Glacier and Deep Archive have retrieval costs (acceptable for archival data)

### Risks

- **Cost Overruns**: If budgets are not set appropriately or alerts are not monitored
- **Performance Impact**: Aggressive right-sizing could impact performance (mitigated by auto-scaling)
- **Storage Retrieval Delays**: Glacier retrieval takes 12 hours (acceptable for archival data)

## Alternatives Considered

### 1. Manual Cost Management
- **Rejected**: Not scalable, error-prone, lacks automation

### 2. Third-Party Cost Management Tools
- **Rejected**: AWS native tools (Cost Explorer, Budgets) are sufficient and integrated

### 3. Aggressive Cost Cutting
- **Rejected**: Could impact performance and reliability. Prefer gradual optimization with monitoring.

### 4. No Reserved Capacity
- **Rejected**: Reserved capacity provides significant savings (up to 72%) for predictable workloads.

## Implementation Notes

1. **Cost Anomaly Detection**: Must be enabled manually in AWS Cost Management Console (cannot be automated via CDK)
2. **Billing Alarms**: Must be created in us-east-1 region and cannot be automated via CDK
3. **Cost Explorer**: Requires 24-48 hours to populate data after resource creation
4. **Tag Propagation**: Tags are applied at stack level and propagate to most resources automatically

## References

- [AWS Well-Architected Framework - Cost Optimization Pillar](https://docs.aws.amazon.com/wellarchitected/latest/cost-optimization-pillar/welcome.html)
- [AWS Cost Management Best Practices](https://docs.aws.amazon.com/cost-management/latest/userguide/best-practices.html)
- [S3 Intelligent-Tiering](https://docs.aws.amazon.com/AmazonS3/latest/userguide/intelligent-tiering.html)
- [AWS Budgets Documentation](https://docs.aws.amazon.com/cost-management/latest/userguide/budgets-managing-costs.html)
- [FinOps Workspace Rules](../../.cursor/rules/13-aws-finops-cost.mdc)

